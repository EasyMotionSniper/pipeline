好的 👍 我来帮你系统梳理 **23种经典设计模式**（GoF - 《Design Patterns》），包括 **分类 → 使用场景 → 细节说明**。

---

# 🏛 23 种设计模式全览

按照 **目的** 分类（GoF 分类法）：

* **创建型 (Creational, 5个)** → 关注对象如何创建
* **结构型 (Structural, 7个)** → 关注对象如何组合
* **行为型 (Behavioral, 11个)** → 关注对象如何交互

---

## 🔹 一、创建型模式（5种）

目标：灵活、安全地创建对象，隐藏具体实现。

1. **单例（Singleton）**

   * **场景**：全局唯一对象（配置中心、线程池、数据库连接池）。
   * **细节**：私有构造函数 + 静态实例 + 线程安全懒加载。
   * **优缺点**：节省资源，但过度使用会增加全局耦合。

2. **工厂方法（Factory Method）**

   * **场景**：需要扩展产品类型（不同数据库连接、不同日志类型）。
   * **细节**：抽象工厂接口 + 子类决定创建何种对象。
   * **优点**：符合开闭原则，便于扩展。

3. **抽象工厂（Abstract Factory）**

   * **场景**：一系列相关产品要成套创建（UI 组件：按钮、文本框、菜单）。
   * **细节**：提供一个接口，创建一组相关对象，不指定具体类。
   * **优点**：保持产品族的一致性。

4. **建造者（Builder）**

   * **场景**：复杂对象逐步构建（汽车装配、SQL 查询构造器）。
   * **细节**：分离构建过程和部件表示，支持链式调用。
   * **优点**：灵活，代码可读性高。

5. **原型（Prototype）**

   * **场景**：对象创建成本高，但可以通过复制已有对象实现（文档复制、深拷贝树结构）。
   * **细节**：实现 `clone()`。
   * **优点**：减少构造开销。

---

## 🔹 二、结构型模式（7种）

目标：组合类或对象，提高复用性和灵活性。

6. **适配器（Adapter）**

   * **场景**：接口不兼容（老接口和新系统对接）。
   * **细节**：包装一个类，让其接口符合目标。
   * **例子**：电源适配器，`List` ↔ `Enumeration` 转换。

7. **桥接（Bridge）**

   * **场景**：对象多维度变化（图形形状 × 渲染方式）。
   * **细节**：抽象和实现分离，通过组合代替继承。
   * **优点**：降低类爆炸风险。

8. **组合（Composite）**

   * **场景**：树形结构（文件系统、菜单）。
   * **细节**：叶子和容器实现统一接口。
   * **优点**：客户端使用时无需区分单个对象或容器。

9. **装饰器（Decorator）**

   * **场景**：动态增加功能（IO 流加缓冲、加密）。
   * **细节**：包装原对象，扩展功能。
   * **优点**：比继承更灵活。

10. **外观（Facade）**

    * **场景**：为复杂子系统提供统一接口（JDBC、Spring JdbcTemplate）。
    * **细节**：简化调用，屏蔽复杂实现。
    * **优点**：降低依赖、提高可用性。

11. **享元（Flyweight）**

    * **场景**：大量对象共享内部状态（文字渲染、棋盘格子）。
    * **细节**：分离 **内在状态（共享）** 和 **外在状态（依赖上下文）**。
    * **优点**：显著节省内存。

12. **代理（Proxy）**

    * **场景**：控制对对象的访问（远程代理、缓存代理、权限代理）。
    * **细节**：代理类持有目标对象引用，拦截请求。
    * **优点**：解耦，增强功能。

---

## 🔹 三、行为型模式（11种）

目标：对象之间如何交互、职责分配。

13. **责任链（Chain of Responsibility）**

    * **场景**：请求在多个处理器中传递（日志过滤器、审批流）。
    * **细节**：每个处理器决定是否处理，或传递给下一个。
    * **优点**：解耦请求和处理逻辑。

14. **命令（Command）**

    * **场景**：请求参数化、可撤销（事务、按钮事件）。
    * **细节**：请求封装为对象，支持撤销、排队。
    * **优点**：解耦调用方和接收方。

15. **解释器（Interpreter）**

    * **场景**：自定义语言、规则引擎（正则解析、SQL 解析）。
    * **细节**：定义语法规则和解释器类。
    * **缺点**：复杂语法不适合。

16. **迭代器（Iterator）**

    * **场景**：遍历集合（STL iterator、Java Iterator）。
    * **细节**：提供统一遍历接口，隐藏内部结构。
    * **优点**：符合单一职责。

17. **中介者（Mediator）**

    * **场景**：多对象复杂交互（聊天室、航班调度）。
    * **细节**：中介者统一协调对象关系。
    * **优点**：避免对象间耦合。

18. **备忘录（Memento）**

    * **场景**：保存和恢复状态（撤销操作、游戏存档）。
    * **细节**：封装内部状态，供后续恢复。
    * **优点**：不破坏封装性。

19. **观察者（Observer）**

    * **场景**：事件订阅通知（GUI 事件、消息总线）。
    * **细节**：Subject 管理 Observer 列表，状态变更时通知。
    * **优点**：松耦合。

20. **状态（State）**

    * **场景**：对象内部状态切换（订单状态、TCP 状态机）。
    * **细节**：状态对象封装行为，环境类持有状态引用。
    * **优点**：消除复杂条件语句。

21. **策略（Strategy）**

    * **场景**：算法可替换（排序策略、压缩算法）。
    * **细节**：定义统一接口，运行时切换实现。
    * **优点**：符合开闭原则。

22. **模板方法（Template Method）**

    * **场景**：固定流程，部分步骤可变（文档生成、数据处理流程）。
    * **细节**：父类定义流程骨架，子类实现可变步骤。
    * **优点**：复用流程控制逻辑。

23. **访问者（Visitor）**

    * **场景**：对复杂对象结构定义新操作（编译器 AST 遍历）。
    * **细节**：将操作从对象结构中分离。
    * **优点**：易于扩展操作，难扩展结构。

---

# 🗂 分类总结

* **创建型（5个）** → 如何创建对象
  单例、工厂方法、抽象工厂、建造者、原型
* **结构型（7个）** → 如何组合对象
  适配器、桥接、组合、装饰器、外观、享元、代理
* **行为型（11个）** → 如何交互和分配职责
  责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者

---

👌 好问题！
设计模式的精髓就是：**稳定点（不变部分）** 与 **变化点（可变部分）分离**。
下面我逐个模式总结 **可变点**（哪里是变化的、需要扩展的），这样你在实际工程里能直接判断“为什么要用这个模式”。

---

# 🔑 23 种设计模式 — 可变点总结

## 🏗 创建型模式

1. **单例 (Singleton)**

   * ✅ 不变：全局唯一实例
   * 🔄 可变：实例的具体实现（懒汉/饿汉/线程安全方式）、是否支持多实例（配置化）

2. **工厂方法 (Factory Method)**

   * ✅ 不变：创建对象的接口
   * 🔄 可变：具体产品类（通过不同子工厂创建不同对象）

3. **抽象工厂 (Abstract Factory)**

   * ✅ 不变：产品族接口（比如 UI 控件组：按钮 + 文本框 + 菜单）
   * 🔄 可变：具体产品族（Windows 风格、Mac 风格、Linux 风格）

4. **建造者 (Builder)**

   * ✅ 不变：构建流程（步骤固定）
   * 🔄 可变：每个步骤的实现（不同建造者构建不同风格对象）

5. **原型 (Prototype)**

   * ✅ 不变：克隆接口
   * 🔄 可变：对象内部状态（深拷贝、浅拷贝、部分属性重设）

---

## 🧩 结构型模式

6. **适配器 (Adapter)**

   * ✅ 不变：目标接口（客户端需要的）
   * 🔄 可变：适配的源类（不同第三方库/旧接口）

7. **桥接 (Bridge)**

   * ✅ 不变：抽象层（功能维度）
   * 🔄 可变：实现层（平台、渲染方式等）

8. **组合 (Composite)**

   * ✅ 不变：整体与部分的统一接口
   * 🔄 可变：树结构中的子节点类型、数量

9. **装饰器 (Decorator)**

   * ✅ 不变：组件接口
   * 🔄 可变：附加的功能（日志、权限、缓存等动态扩展）

10. **外观 (Facade)**

* ✅ 不变：对外暴露的简化接口
* 🔄 可变：内部子系统实现（数据库换成云服务等）

11. **享元 (Flyweight)**

* ✅ 不变：内部共享状态（不可变部分，如棋子颜色）
* 🔄 可变：外部非共享状态（棋子位置）

12. **代理 (Proxy)**

* ✅ 不变：代理与真实对象的接口一致
* 🔄 可变：代理的附加功能（延迟加载、权限控制、远程调用）

---

## 🎭 行为型模式

13. **责任链 (Chain of Responsibility)**

* ✅ 不变：请求沿链条传递机制
* 🔄 可变：链中节点的数量、顺序、处理逻辑

14. **命令 (Command)**

* ✅ 不变：命令调用接口
* 🔄 可变：命令的具体实现（打印、保存、撤销等）

15. **解释器 (Interpreter)**

* ✅ 不变：语法规则定义
* 🔄 可变：语法扩展、具体表达式实现

16. **迭代器 (Iterator)**

* ✅ 不变：遍历接口（`next()`、`hasNext()`）
* 🔄 可变：集合内部结构、遍历方式（正序、逆序、跳步）

17. **中介者 (Mediator)**

* ✅ 不变：对象通过中介通信
* 🔄 可变：中介者的调度逻辑（广播、单播、优先级）

18. **备忘录 (Memento)**

* ✅ 不变：存储和恢复状态接口
* 🔄 可变：保存的状态内容（全部状态/部分状态/压缩存储）

19. **观察者 (Observer)**

* ✅ 不变：一对多通知机制
* 🔄 可变：观察者列表、通知策略（同步/异步/过滤）

20. **状态 (State)**

* ✅ 不变：状态切换机制
* 🔄 可变：具体状态类、状态转移规则

21. **策略 (Strategy)**

* ✅ 不变：策略接口
* 🔄 可变：算法实现（快排、归并、计数排序等）

22. **模板方法 (Template Method)**

* ✅ 不变：固定流程框架
* 🔄 可变：子类实现的步骤（钩子方法）

23. **访问者 (Visitor)**

* ✅ 不变：访问者接口、元素结构固定
* 🔄 可变：访问者的具体实现（统计、打印、校验）

---

# 🎯 总结

* **不变部分 = 稳定接口/框架**
* **可变部分 = 业务扩展/实现细节**

所以设计模式的本质就是：
👉 把 **变化点** 封装到独立类/对象/函数里，隔离出来，让系统主体保持稳定。

---

